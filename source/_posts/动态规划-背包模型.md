---
title: 动态规划-背包模型
date: 2021-01-28 16:01:00
tags:
- 动态规划
- 背包
- AcWing
categories:
- 数据结构与算法
---
把背包模型总结一下
<!--more-->

## 01背包

[2. 01背包问题](https://www.acwing.com/problem/content/2/)

01背包问题每样物品只有取和不取两种状态。

朴素做法：
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N][N], v[N], w[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++)
        {
            // 不可以装的话
            // if(v[i] > j) f[i][j] = f[i-1][j];
            // 能装的话
            // else f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i]);
            // 可以简化为如下
            f[i][j] = f[i-1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i-1][j-v[i]] + w[i]);
        }
            
    cout << f[n][m] << endl;
    return 0;
}
```

优化为一维数组：
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N], v[N], w[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= v[i]; j--)
            // 滚动数组
            // f[j-v[i]]需要使用上一轮的值，如果从前开始循环的话会把旧值更新
            // 从后往前可以避免这个问题
            f[j] = max(f[j], f[j-v[i]] + w[i]);
            
    cout << f[m] << endl;
    return 0;
}
```

## 完全背包

完全背包就是01背包基础上让物品取用次数变为无限次。

[3. 完全背包问题](https://www.acwing.com/problem/content/3/)

朴素做法，时间复杂度$O(nm^2)$，容易**TLE**
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N][N], v[N], w[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            for(int k = 0; k*v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k * w[i]);
    cout << f[n][m] << endl;
    return 0;
}
```

稍微优化，由朴素做法中：

$$
f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-k*v[i]] + k * w[i], ...)
$$

由于

$$
f[i][j-v[i]] = max(f[i-1][j-v[i]], f[i-1][j-2*v[i]] + w[i], f[i-1][j-k*v[i]] + (k-1) * w[i], ...)
$$

因此可以替换为

$$
f[i][j] = max(f[i-1][j], f[i][j-v[i]] + w[i])
$$

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N][N], v[N], w[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            f[i][j] = f[i-1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]);
        }
    cout << f[n][m] << endl;
    return 0;
}
```

一维优化，这里优化的思路和01背包优化思路一致，只不过01背包是因为$f[i-1][j-v[i]] + w[i]$需要取上一轮的旧值才需要从后往前，而完全背包这里$f[i][j-v[i]] + w[i]$取的是这轮刚更新的新值，因此就可以从前往后了。
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N], v[N], w[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = v[i]; j <= m; j++)
            f[j] = max(f[j], f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

## 多重背包

多重背包就是完全背包基础上加入了物品的数量限制。

朴素做法：[4. 多重背包问题 I](https://www.acwing.com/problem/content/4/)

多重背包的朴素做法思路和完全背包朴素做法思路一致，即多加入物品数目的限制即可。

时间复杂度$O(n^3)$
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 110;
int f[N][N], v[N], w[N], s[N];

int main()
{
    int n, m;
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i] >> s[i];
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            for(int k = 0; k <= s[i] && k*v[i] <= j; k++)
                f[i][j] = max(f[i][j], f[i-1][j - k*v[i]] + k * w[i]);
    cout << f[n][m] << endl;
    return 0;
}
```

二进制优化：[5. 多重背包问题 II](https://www.acwing.com/problem/content/5/)

由于多重背包问题在物品数量上做了限制，所以是无法用完全背包的优化思路去优化的。

// TODO 待补充

```c++

```

## 分组背包

[9. 分组背包问题](https://www.acwing.com/problem/content/9/)

分组背包问题其实就是01背包问题稍微变了一点，01背包是这个物品选或不选，而分组背包是这个组里的这个物品选还是不选。

朴素做法
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 110;
int f[N][N], v[N][N], w[N][N], s[N];

int main()
{
    int n, m;
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for(int j = 1; j <= s[i]; j++) cin >> v[i][j] >> w[i][j];
    }
    
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            f[i][j] = f[i-1][j];
            for(int k = 1; k <= s[i]; k++)
                if(j >= v[i][k]) f[i][j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k]);
        }
    cout << f[n][m] << endl;
    return 0;
}
```

一维优化

优化思路也跟01背包思路一致。
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 110;
int f[N], v[N][N], w[N][N], s[N];

int main()
{
    int n, m;
    cin >> n >> m;
    
    for(int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for(int j = 1; j <= s[i]; j++) cin >> v[i][j] >> w[i][j];
    }
    
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= 1; j--)
        {
            for(int k = 1; k <= s[i]; k++)
                if(j >= v[i][k]) f[j] = max(f[j], f[j-v[i][k]] + w[i][k]);
        }
    cout << f[m] << endl;
    return 0;
}
```

## 二维费用的背包

[8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/)

二维费用问题就是在体积的基础上多加一维，例题中基于01背包拓展，其实也可以用在完全、多重和分组背包。

朴素做法

就是多加了一维
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N][N][N], n, V, M;

int main()
{
    cin >> n >> V >> M;
    for(int i = 1; i <= n; i++)
    {
        int v, m, w;
        cin >> v >> m >> w;
        for(int j = 1; j <= V; j++)
            for(int k = 1; k <= M; k++)
            {
                f[i][j][k] = f[i-1][j][k];
                if(j >= v && k >= m) f[i][j][k] = max(f[i][j][k], f[i-1][j-v][k-m] + w);
            }
    }
    cout << f[n][V][M] << endl;
    return 0;
}
```

一维优化

优化思路一致
```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N][N], n, V, M;

int main()
{
    cin >> n >> V >> M;
    for(int i = 1; i <= n; i++)
    {
        int v, m, w;
        cin >> v >> m >> w;
        for(int j = V; j >= v; j--)
            for(int k = M; k >= m; k--)
                f[j][k] = max(f[j][k], f[j-v][k-m] + w);
    }
    cout << f[V][M] << endl;
    return 0;
}
```

## 体积正好用完的完全背包方案数

[1023. 买书](https://www.acwing.com/problem/content/1025/)

朴素做法

注意一下当没钱的时候，不买书也算一种方案。

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N][N], v[5];

int main()
{
    int n;
    cin >> n;
    v[1] = 10, v[2] = 20, v[3] = 50, v[4] = 100;
    
    for(int i = 0; i <= 4; i++) f[i][0] = 1;
    
    for(int i = 1; i <= 4; i++)
        for(int j = 1; j <= n; j++)
            for(int k = 0; j >= k*v[i]; k++)
                f[i][j] += f[i-1][j-k*v[i]];
    cout << f[4][n] << endl;
    return 0;
}
```

一维优化

优化方法跟完全背包优化方法思路一致，不再赘述

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1010;
int f[N], v[5];

int main()
{
    int n;
    cin >> n;
    v[1] = 10, v[2] = 20, v[3] = 50, v[4] = 100;
    
    f[0] = 1;
    
    for(int i = 1; i <= 4; i++)
        for(int j = v[i]; j <= n; j++)
            f[j] = f[j] + f[j-v[i]];
                
    cout << f[n] << endl;
    return 0;
}
```

**未完待续...**